
#version 450

struct Particle {
    vec3 position;
    vec3 velocity;
    vec2 uv;
    vec3 normal;
};

layout (std430, set = 0, binding = 0) readonly buffer Input {
    Particle particles[];
} input_ssbo;

layout (std430, set = 0, binding = 1) buffer Output {
    Particle particles[];
} output_ssbo;

layout (set = 0, binding = 2) uniform SimulationUniforms {
    float dt;
    float particle_mass; // Assuming all particles have the same mass
    float spring_length; // Spring resting length
    float spring_length_diagonal;

    vec3 gravity; // Wind is simulated by adding force of gravity in a direction
    float spring_stiffness; // k, spring stiffness coefficient

    vec3 sphere_position;
    float sphere_radius;

    float dampening; // Dampening factor
    int dimension; // Size of one side of the cloth
} simulation;

vec3 hookes_law(vec3 p0, vec3 p1, float spring_length) {
    // Restitution force is proportional to the distance the spring is stretched past its resting length
    vec3 dist = p0 - p1;
    return normalize(dist) * simulation.spring_stiffness * (length(dist) - spring_length);
}

// Invocation group size
// Compute shader runs in groups of 10 x 10 x 1
layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

uint get_index(uint x, uint y) {
    return x + y * simulation.dimension;
}

void main() {
    uvec3 id = gl_GlobalInvocationID;
    uint index = get_index(id.x, id.y); // Particle index

    if (index > simulation.dimension * simulation.dimension) {
        // Ideally, the workgroup * invocation group sizes line up perfectly, as this otherwise results in GPU threads waiting idle
        return;
    }

    vec3 force = simulation.particle_mass * simulation.gravity;

    // Apply spring forces from neighboring particles
    // The cloth is connected to all 8 of its neighbors by springs simulated by Hooke's Law

    // left
    if (id.x > 0) {
        uint idx = get_index(id.x - 1, id.y);
        force += hookes_law(input_ssbo.particles[idx].position, input_ssbo.particles[index].position, simulation.spring_length);
    }

    // right
    if (id.x < simulation.dimension - 1) {
        uint idx = get_index(id.x + 1, id.y);
        force += hookes_law(input_ssbo.particles[idx].position, input_ssbo.particles[index].position, simulation.spring_length);
    }

    // up
    if (id.y > 0) {
        uint idx = get_index(id.x, id.y - 1);
        force += hookes_law(input_ssbo.particles[idx].position, input_ssbo.particles[index].position, simulation.spring_length);
    }

    // down
    if (id.y < simulation.dimension - 1) {
        uint idx = get_index(id.x, id.y + 1);
        force += hookes_law(input_ssbo.particles[idx].position, input_ssbo.particles[index].position, simulation.spring_length);
    }

//    // top left
//    if (id.x > 0 && id.y > 0) {
//        force += hookes_law(input_ssbo.particles[index - 1 - simulation.dimension].position, input_ssbo.particles[index].position, simulation.spring_length_diagonal);
//    }
//
//    // top right
//    if (id.x < simulation.dimension - 1 && id.y > 0) {
//        force += hookes_law(input_ssbo.particles[index + 1 - simulation.dimension].position, input_ssbo.particles[index].position, simulation.spring_length_diagonal);
//    }
//
//    // bottom left
//    if (id.x > 0 && id.y < simulation.dimension - 1) {
//        force += hookes_law(input_ssbo.particles[index - 1 + simulation.dimension].position, input_ssbo.particles[index].position, simulation.spring_length_diagonal);
//    }
//
//    // bottom right
//    if (id.x < simulation.dimension - 1 && id.y < simulation.dimension - 1) {
//        force += hookes_law(input_ssbo.particles[index + 1 + simulation.dimension].position, input_ssbo.particles[index].position, simulation.spring_length_diagonal);
//    }

    force -= simulation.dampening * input_ssbo.particles[index].velocity;

    // acceleration = force / mass
    vec3 acceleration = force / simulation.particle_mass;

        // Change in position
    // x = x + v * t + 1 / 2 * a * t ^ 2
    // output_ssbo.particles[index].position = input_ssbo.particles[index].position + force * simulation.dt;
//    output_ssbo.particles[index].position = input_ssbo.particles[index].position + input_ssbo.particles[index].velocity * simulation.dt + 0.5f * acceleration * simulation.dt * simulation.dt;

    // Change in velocity
    // v = u + a * t
//     output_ssbo.particles[index].velocity = input_ssbo.particles[index].velocity + acceleration * simulation.dt;

    vec3 velocity = input_ssbo.particles[index].velocity + acceleration * simulation.dt;
    vec3 position = input_ssbo.particles[index].position + velocity * simulation.dt;

    output_ssbo.particles[index].position = position;
    output_ssbo.particles[index].velocity = velocity;

    // Detect collision with the model
    // The model used for this sample is a sphere to simplify collision detection + resolution processes
    vec3 to_sphere = output_ssbo.particles[index].position - simulation.sphere_position;
    float offset = 0.01f; // Slighly offset past the sphere surface to prevent z fighting
    if (length(to_sphere) < simulation.sphere_radius + offset) {
        // Particle is inside the sphere
        // Resolve collision so that the particle's position is on the surface of the sphere
        output_ssbo.particles[index].position = simulation.sphere_position + normalize(to_sphere) * (simulation.sphere_radius + offset);
        output_ssbo.particles[index].velocity = vec3(0.0f);
    }

    // Calculate normals
}